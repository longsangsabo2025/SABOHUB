import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../models/daily_work_report.dart';
import '../providers/attendance_provider.dart';

/// Daily Work Report Service
/// Auto-generates work reports when employee checks out
class DailyWorkReportService {
  // Mock storage for demo
  static final List<DailyWorkReport> _mockReports = [];

  /// Generate report from attendance data
  /// Called automatically when employee checks out
  Future<DailyWorkReport> generateReportFromCheckout({
    required Attendance attendance,
    required String userName,
    List<TaskSummary>? completedTasks,
  }) async {
    // Simulate API processing delay
    await Future.delayed(const Duration(milliseconds: 500));

    // Calculate work hours
    final checkIn = attendance.checkInTime!;
    final checkOut = attendance.checkOutTime!;
    final totalHours = checkOut.difference(checkIn).inMinutes / 60.0;

    // Auto-collect task data
    final tasks =
        completedTasks ?? await _collectTodayCompletedTasks(attendance.userId);

    // Generate summary based on work data
    final autoSummary = _generateWorkSummary(
      totalHours: totalHours,
      tasksCompleted: tasks.length,
      tasks: tasks,
    );

    // Create report draft
    final report = DailyWorkReport(
      id: 'report_${DateTime.now().millisecondsSinceEpoch}',
      userId: attendance.userId,
      userName: userName,
      branchId: attendance.branchId,
      date: attendance.date,
      checkInTime: checkIn,
      checkOutTime: checkOut,
      totalHours: totalHours,
      tasksCompleted: tasks.length,
      tasksAssigned: tasks.length, // TODO: Get from task service
      completedTasks: tasks,
      autoGeneratedSummary: autoSummary,
      status: ReportStatus.draft,
      createdAt: DateTime.now(),
    );

    // Store report (mock)
    _mockReports.add(report);

    return report;
  }

  /// Auto-collect completed tasks from today's shift
  Future<List<TaskSummary>> _collectTodayCompletedTasks(String userId) async {
    // TODO: Query actual task data from Supabase
    // For now, return mock data
    await Future.delayed(const Duration(milliseconds: 200));

    // Example tasks completed during shift
    return [
      TaskSummary(
        taskId: 'task_1',
        taskTitle: 'V·ªá sinh khu v·ª±c l√†m vi·ªác',
        taskDescription: 'Lau s·∫°ch b√†n gh·∫ø, s·∫Øp x·∫øp ƒë·ªì d√πng',
        completedAt: DateTime.now().subtract(const Duration(hours: 2)),
        notes: 'Ho√†n th√†nh t·ªët, khu v·ª±c s·∫°ch s·∫Ω',
      ),
      TaskSummary(
        taskId: 'task_2',
        taskTitle: 'Ki·ªÉm tra thi·∫øt b·ªã',
        taskDescription: 'Ki·ªÉm tra m√°y m√≥c ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng',
        completedAt: DateTime.now().subtract(const Duration(hours: 1)),
      ),
    ];
  }

  /// Generate AI-powered work summary
  String _generateWorkSummary({
    required double totalHours,
    required int tasksCompleted,
    required List<TaskSummary> tasks,
  }) {
    final buffer = StringBuffer();

    // Summary header
    buffer.writeln('üìä T√≥m t·∫Øt ca l√†m vi·ªác:');
    buffer.writeln('');

    // Work hours
    buffer
        .writeln('‚è∞ Th·ªùi gian l√†m vi·ªác: ${totalHours.toStringAsFixed(1)} gi·ªù');
    buffer.writeln('‚úÖ Ho√†n th√†nh: $tasksCompleted c√¥ng vi·ªác');
    buffer.writeln('');

    // Task details
    if (tasks.isNotEmpty) {
      buffer.writeln('üìù Chi ti·∫øt c√¥ng vi·ªác:');
      for (var i = 0; i < tasks.length; i++) {
        final task = tasks[i];
        buffer.writeln('${i + 1}. ${task.taskTitle}');
        if (task.notes != null) {
          buffer.writeln('   ‚Üí ${task.notes}');
        }
      }
      buffer.writeln('');
    }

    // Performance evaluation
    final performance = _evaluatePerformance(totalHours, tasksCompleted);
    buffer.writeln('üéØ ƒê√°nh gi√°: $performance');

    return buffer.toString();
  }

  /// Evaluate work performance
  String _evaluatePerformance(double totalHours, int tasksCompleted) {
    if (totalHours >= 8 && tasksCompleted >= 3) {
      return 'Xu·∫•t s·∫Øc - L√†m vi·ªác chƒÉm ch·ªâ, ho√†n th√†nh nhi·ªÅu c√¥ng vi·ªác';
    } else if (totalHours >= 6 && tasksCompleted >= 2) {
      return 'T·ªët - ƒê·∫°t m·ª•c ti√™u c√¥ng vi·ªác';
    } else if (totalHours >= 4 && tasksCompleted >= 1) {
      return 'Trung b√¨nh - C·∫ßn c·∫£i thi·ªán hi·ªáu su·∫•t';
    } else {
      return 'C·∫ßn c·ªë g·∫Øng th√™m';
    }
  }

  /// Update report with employee notes
  Future<DailyWorkReport> updateReport({
    required String reportId,
    String? employeeNotes,
    List<String>? achievements,
    List<String>? challenges,
    String? tomorrowPlan,
  }) async {
    await Future.delayed(const Duration(milliseconds: 300));

    final index = _mockReports.indexWhere((r) => r.id == reportId);
    if (index == -1) {
      throw Exception('Report not found');
    }

    final updatedReport = _mockReports[index].copyWith(
      employeeNotes: employeeNotes,
      achievements: achievements,
      challenges: challenges,
      tomorrowPlan: tomorrowPlan,
      updatedAt: DateTime.now(),
    );

    _mockReports[index] = updatedReport;
    return updatedReport;
  }

  /// Submit report
  Future<DailyWorkReport> submitReport(String reportId) async {
    await Future.delayed(const Duration(milliseconds: 300));

    final index = _mockReports.indexWhere((r) => r.id == reportId);
    if (index == -1) {
      throw Exception('Report not found');
    }

    final submittedReport = _mockReports[index].copyWith(
      status: ReportStatus.submitted,
      submittedAt: DateTime.now(),
    );

    _mockReports[index] = submittedReport;
    return submittedReport;
  }

  /// Get report by ID
  Future<DailyWorkReport?> getReport(String reportId) async {
    await Future.delayed(const Duration(milliseconds: 200));
    try {
      return _mockReports.firstWhere((r) => r.id == reportId);
    } catch (e) {
      return null;
    }
  }

  /// Get all reports for user
  Future<List<DailyWorkReport>> getUserReports(String userId) async {
    await Future.delayed(const Duration(milliseconds: 300));
    return _mockReports.where((r) => r.userId == userId).toList()
      ..sort((a, b) => b.date.compareTo(a.date));
  }

  /// Get today's report for user (if exists)
  Future<DailyWorkReport?> getTodayReport(String userId) async {
    await Future.delayed(const Duration(milliseconds: 200));

    final today = DateTime.now();
    final todayStart = DateTime(today.year, today.month, today.day);

    try {
      return _mockReports.firstWhere((r) =>
          r.userId == userId &&
          r.date.isAfter(todayStart) &&
          r.date.isBefore(todayStart.add(const Duration(days: 1))));
    } catch (e) {
      return null;
    }
  }

  /// Get reports by date range
  Future<List<DailyWorkReport>> getReportsByDateRange({
    required String userId,
    required DateTime startDate,
    required DateTime endDate,
  }) async {
    await Future.delayed(const Duration(milliseconds: 300));

    return _mockReports
        .where((r) =>
            r.userId == userId &&
            r.date.isAfter(startDate.subtract(const Duration(days: 1))) &&
            r.date.isBefore(endDate.add(const Duration(days: 1))))
        .toList()
      ..sort((a, b) => b.date.compareTo(a.date));
  }

  /// Delete draft report
  Future<void> deleteDraftReport(String reportId) async {
    await Future.delayed(const Duration(milliseconds: 200));

    final report = _mockReports.firstWhere((r) => r.id == reportId);
    if (report.status != ReportStatus.draft) {
      throw Exception('Can only delete draft reports');
    }

    _mockReports.removeWhere((r) => r.id == reportId);
  }

  /// Get statistics for manager view
  Future<Map<String, dynamic>> getReportStatistics({
    required String companyId,
    required DateTime date,
  }) async {
    await Future.delayed(const Duration(milliseconds: 400));

    // TODO: Query from Supabase with proper filters
    final dayReports = _mockReports.where((r) {
      final reportDate = r.date;
      return reportDate.year == date.year &&
          reportDate.month == date.month &&
          reportDate.day == date.day;
    }).toList();

    final totalReports = dayReports.length;
    final submittedReports =
        dayReports.where((r) => r.status == ReportStatus.submitted).length;
    final avgHours = dayReports.isEmpty
        ? 0.0
        : dayReports.map((r) => r.totalHours).reduce((a, b) => a + b) /
            totalReports;
    final totalTasks = dayReports
        .map((r) => r.tasksCompleted)
        .fold(0, (sum, count) => sum + count);

    return {
      'total_reports': totalReports,
      'submitted_reports': submittedReports,
      'pending_reports': totalReports - submittedReports,
      'average_hours': avgHours,
      'total_tasks_completed': totalTasks,
      'submission_rate':
          totalReports > 0 ? (submittedReports / totalReports * 100) : 0,
    };
  }
}

// Riverpod Providers
final dailyWorkReportServiceProvider = Provider<DailyWorkReportService>((ref) {
  return DailyWorkReportService();
});

/// Today's report for current user
final todayWorkReportProvider =
    FutureProvider.family<DailyWorkReport?, String>((ref, userId) async {
  final service = ref.watch(dailyWorkReportServiceProvider);
  return await service.getTodayReport(userId);
});

/// All reports for user
final userWorkReportsProvider =
    FutureProvider.family<List<DailyWorkReport>, String>((ref, userId) async {
  final service = ref.watch(dailyWorkReportServiceProvider);
  return await service.getUserReports(userId);
});

/// Report statistics for manager
final reportStatisticsProvider =
    FutureProvider.family<Map<String, dynamic>, Map<String, dynamic>>(
        (ref, params) async {
  final service = ref.watch(dailyWorkReportServiceProvider);
  return await service.getReportStatistics(
    companyId: params['companyId'] as String,
    date: params['date'] as DateTime,
  );
});
