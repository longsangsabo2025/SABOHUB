import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

import '../models/daily_work_report.dart';
import '../providers/attendance_provider.dart';

/// Daily Work Report Service
/// Auto-generates work reports when employee checks out
class DailyWorkReportService {
  final SupabaseClient _supabase;
  
  DailyWorkReportService(this._supabase);
  
  // Mock storage for demo (fallback)
  static final List<DailyWorkReport> _mockReports = [];

  /// Generate report from attendance data
  /// Called automatically when employee checks out
  Future<DailyWorkReport> generateReportFromCheckout({
    required Attendance attendance,
    required String userName,
    required String? companyId, // Add companyId parameter
    required String? userRole,  // Add userRole parameter
    List<TaskSummary>? completedTasks,
  }) async {
    // Simulate API processing delay
    await Future.delayed(const Duration(milliseconds: 500));

    // Calculate work hours
    final checkIn = attendance.checkInTime!;
    final checkOut = attendance.checkOutTime!;
    final totalHours = checkOut.difference(checkIn).inMinutes / 60.0;

    // Auto-collect task data
    final tasks =
        completedTasks ?? await _collectTodayCompletedTasks(attendance.userId);

    // Generate summary based on work data
    final autoSummary = _generateWorkSummary(
      totalHours: totalHours,
      tasksCompleted: tasks.length,
      tasks: tasks,
    );

    // Create report draft
    final report = DailyWorkReport(
      id: 'report_${DateTime.now().millisecondsSinceEpoch}',
      userId: attendance.userId,
      userName: userName,
      branchId: attendance.branchId,
      date: attendance.date,
      checkInTime: checkIn,
      checkOutTime: checkOut,
      totalHours: totalHours,
      tasksCompleted: tasks.length,
      tasksAssigned: tasks.length, // TODO: Get from task service
      completedTasks: tasks,
      autoGeneratedSummary: autoSummary,
      status: ReportStatus.draft,
      createdAt: DateTime.now(),
    );

    // Save to Supabase
    try {
      await _saveReportToDatabase(report, companyId, userRole);
      print('‚úÖ Report saved to database: ${report.id}');
    } catch (e) {
      print('‚ö†Ô∏è Failed to save report to database: $e');
      // Continue anyway - report still exists in memory
    }

    // Store report (mock fallback)
    _mockReports.add(report);

    return report;
  }
  
  /// Save report to Supabase daily_work_reports table
  Future<void> _saveReportToDatabase(
    DailyWorkReport report,
    String? companyId,
    String? userRole,
  ) async {
    final data = {
      'employee_id': report.userId,  // Changed from user_id to employee_id
      'company_id': companyId ?? '', // From user
      'branch_id': report.branchId,
      'report_date': report.date.toIso8601String().split('T')[0], // YYYY-MM-DD
      'check_in_time': report.checkInTime.toIso8601String(),
      'check_out_time': report.checkOutTime.toIso8601String(),
      'total_hours': report.totalHours,
      'tasks_summary': _formatTasksSummary(report.completedTasks),
      'achievements': report.achievements?.join('\n'),
      'challenges': report.challenges?.join('\n'),
      'notes': report.employeeNotes,
      'employee_name': report.userName,
      'employee_role': userRole ?? 'STAFF',
    };

    await _supabase.from('daily_work_reports').insert(data);
  }
  
  /// Format tasks into summary text
  String _formatTasksSummary(List<TaskSummary> tasks) {
    if (tasks.isEmpty) return 'Kh√¥ng c√≥ c√¥ng vi·ªác ƒë∆∞·ª£c ghi nh·∫≠n';
    
    final buffer = StringBuffer();
    for (var i = 0; i < tasks.length; i++) {
      final task = tasks[i];
      buffer.writeln('${i + 1}. ${task.taskTitle}');
      if (task.taskDescription != null) {
        buffer.writeln('   ${task.taskDescription}');
      }
      if (task.notes != null) {
        buffer.writeln('   ‚Üí ${task.notes}');
      }
    }
    return buffer.toString();
  }

  /// Auto-collect completed tasks from today's shift
  Future<List<TaskSummary>> _collectTodayCompletedTasks(String userId) async {
    // TODO: Query actual task data from Supabase
    // For now, return mock data
    await Future.delayed(const Duration(milliseconds: 200));

    // Example tasks completed during shift
    return [
      TaskSummary(
        taskId: 'task_1',
        taskTitle: 'V·ªá sinh khu v·ª±c l√†m vi·ªác',
        taskDescription: 'Lau s·∫°ch b√†n gh·∫ø, s·∫Øp x·∫øp ƒë·ªì d√πng',
        completedAt: DateTime.now().subtract(const Duration(hours: 2)),
        notes: 'Ho√†n th√†nh t·ªët, khu v·ª±c s·∫°ch s·∫Ω',
      ),
      TaskSummary(
        taskId: 'task_2',
        taskTitle: 'Ki·ªÉm tra thi·∫øt b·ªã',
        taskDescription: 'Ki·ªÉm tra m√°y m√≥c ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng',
        completedAt: DateTime.now().subtract(const Duration(hours: 1)),
      ),
    ];
  }

  /// Generate AI-powered work summary
  String _generateWorkSummary({
    required double totalHours,
    required int tasksCompleted,
    required List<TaskSummary> tasks,
  }) {
    final buffer = StringBuffer();

    // Summary header
    buffer.writeln('üìä T√≥m t·∫Øt ca l√†m vi·ªác:');
    buffer.writeln('');

    // Work hours
    buffer
        .writeln('‚è∞ Th·ªùi gian l√†m vi·ªác: ${totalHours.toStringAsFixed(1)} gi·ªù');
    buffer.writeln('‚úÖ Ho√†n th√†nh: $tasksCompleted c√¥ng vi·ªác');
    buffer.writeln('');

    // Task details
    if (tasks.isNotEmpty) {
      buffer.writeln('üìù Chi ti·∫øt c√¥ng vi·ªác:');
      for (var i = 0; i < tasks.length; i++) {
        final task = tasks[i];
        buffer.writeln('${i + 1}. ${task.taskTitle}');
        if (task.notes != null) {
          buffer.writeln('   ‚Üí ${task.notes}');
        }
      }
      buffer.writeln('');
    }

    // Performance evaluation
    final performance = _evaluatePerformance(totalHours, tasksCompleted);
    buffer.writeln('üéØ ƒê√°nh gi√°: $performance');

    return buffer.toString();
  }

  /// Evaluate work performance
  String _evaluatePerformance(double totalHours, int tasksCompleted) {
    if (totalHours >= 8 && tasksCompleted >= 3) {
      return 'Xu·∫•t s·∫Øc - L√†m vi·ªác chƒÉm ch·ªâ, ho√†n th√†nh nhi·ªÅu c√¥ng vi·ªác';
    } else if (totalHours >= 6 && tasksCompleted >= 2) {
      return 'T·ªët - ƒê·∫°t m·ª•c ti√™u c√¥ng vi·ªác';
    } else if (totalHours >= 4 && tasksCompleted >= 1) {
      return 'Trung b√¨nh - C·∫ßn c·∫£i thi·ªán hi·ªáu su·∫•t';
    } else {
      return 'C·∫ßn c·ªë g·∫Øng th√™m';
    }
  }

  /// Update report with employee notes
  Future<DailyWorkReport> updateReport({
    required String reportId,
    String? employeeNotes,
    List<String>? achievements,
    List<String>? challenges,
    String? tomorrowPlan,
  }) async {
    await Future.delayed(const Duration(milliseconds: 300));

    final index = _mockReports.indexWhere((r) => r.id == reportId);
    if (index == -1) {
      throw Exception('Report not found');
    }

    final updatedReport = _mockReports[index].copyWith(
      employeeNotes: employeeNotes,
      achievements: achievements,
      challenges: challenges,
      tomorrowPlan: tomorrowPlan,
      updatedAt: DateTime.now(),
    );

    _mockReports[index] = updatedReport;
    return updatedReport;
  }

  /// Submit report
  Future<DailyWorkReport> submitReport(String reportId) async {
    await Future.delayed(const Duration(milliseconds: 300));

    final index = _mockReports.indexWhere((r) => r.id == reportId);
    if (index == -1) {
      throw Exception('Report not found');
    }

    final submittedReport = _mockReports[index].copyWith(
      status: ReportStatus.submitted,
      submittedAt: DateTime.now(),
    );

    _mockReports[index] = submittedReport;
    return submittedReport;
  }

  /// Get report by ID
  Future<DailyWorkReport?> getReport(String reportId) async {
    await Future.delayed(const Duration(milliseconds: 200));
    try {
      return _mockReports.firstWhere((r) => r.id == reportId);
    } catch (e) {
      return null;
    }
  }

  /// Get all reports for user
  Future<List<DailyWorkReport>> getUserReports(String userId) async {
    try {
      // Query from Supabase - use employee_id
      final response = await _supabase
          .from('daily_work_reports')
          .select('*')
          .eq('employee_id', userId)  // Changed from user_id to employee_id
          .order('report_date', ascending: false);

      // Map to DailyWorkReport objects
      final reports = (response as List).map((json) {
        return DailyWorkReport(
          id: json['id'] as String,
          userId: json['employee_id'] as String,  // Changed from user_id to employee_id
          userName: json['employee_name'] as String? ?? 'Nh√¢n vi√™n',
          branchId: json['branch_id'] as String?,
          date: DateTime.parse(json['report_date'] as String),
          checkInTime: DateTime.parse(json['check_in_time'] as String),
          checkOutTime: DateTime.parse(json['check_out_time'] as String),
          totalHours: (json['total_hours'] as num).toDouble(),
          tasksCompleted: 0, // Will be calculated from tasks_summary
          tasksAssigned: 0,
          completedTasks: _parseTasksSummary(json['tasks_summary'] as String?),
          autoGeneratedSummary: json['achievements'] as String? ?? '',
          employeeNotes: json['notes'] as String?,
          status: ReportStatus.submitted, // All DB records are submitted
          createdAt: DateTime.parse(json['created_at'] as String),
          submittedAt: DateTime.parse(json['created_at'] as String),
        );
      }).toList();

      return reports;
    } catch (e) {
      print('‚ö†Ô∏è Error fetching reports from database: $e');
      // Fallback to mock data
      return _mockReports.where((r) => r.userId == userId).toList()
        ..sort((a, b) => b.date.compareTo(a.date));
    }
  }

  /// Parse tasks summary from database text format
  List<TaskSummary> _parseTasksSummary(String? summary) {
    if (summary == null || summary.isEmpty) return [];
    
    // Simple parsing - split by newlines and create task summaries
    final lines = summary.split('\n').where((line) => line.trim().isNotEmpty);
    return lines.map((line) {
      return TaskSummary(
        taskId: 'task_${line.hashCode}',
        taskTitle: line.replaceAll(RegExp(r'^[‚Ä¢\-\*]\s*'), '').trim(),
        completedAt: DateTime.now(), // Approximate
      );
    }).toList();
  }

  /// Get today's report for user (if exists)
  Future<DailyWorkReport?> getTodayReport(String userId) async {
    await Future.delayed(const Duration(milliseconds: 200));

    final today = DateTime.now();
    final todayStart = DateTime(today.year, today.month, today.day);

    try {
      return _mockReports.firstWhere((r) =>
          r.userId == userId &&
          r.date.isAfter(todayStart) &&
          r.date.isBefore(todayStart.add(const Duration(days: 1))));
    } catch (e) {
      return null;
    }
  }

  /// Get all reports for branch (Manager view)
  Future<List<DailyWorkReport>> getBranchReports(String branchId) async {
    try {
      // Query from Supabase
      final response = await _supabase
          .from('daily_work_reports')
          .select('*')
          .eq('branch_id', branchId)
          .order('report_date', ascending: false);

      // Map to DailyWorkReport objects
      final reports = (response as List).map((json) {
        return DailyWorkReport(
          id: json['id'] as String,
          userId: json['employee_id'] as String,  // Changed from user_id to employee_id
          userName: json['employee_name'] as String? ?? 'Nh√¢n vi√™n',
          branchId: json['branch_id'] as String?,
          date: DateTime.parse(json['report_date'] as String),
          checkInTime: DateTime.parse(json['check_in_time'] as String),
          checkOutTime: DateTime.parse(json['check_out_time'] as String),
          totalHours: (json['total_hours'] as num).toDouble(),
          tasksCompleted: 0,
          tasksAssigned: 0,
          completedTasks: _parseTasksSummary(json['tasks_summary'] as String?),
          autoGeneratedSummary: json['achievements'] as String? ?? '',
          employeeNotes: json['notes'] as String?,
          status: ReportStatus.submitted,
          createdAt: DateTime.parse(json['created_at'] as String),
          submittedAt: DateTime.parse(json['created_at'] as String),
        );
      }).toList();

      return reports;
    } catch (e) {
      print('‚ö†Ô∏è Error fetching branch reports from database: $e');
      // Fallback to mock data
      return _mockReports.where((r) => r.branchId == branchId).toList()
        ..sort((a, b) => b.date.compareTo(a.date));
    }
  }

  /// Get reports by date range
  Future<List<DailyWorkReport>> getReportsByDateRange({
    required String userId,
    required DateTime startDate,
    required DateTime endDate,
  }) async {
    await Future.delayed(const Duration(milliseconds: 300));

    return _mockReports
        .where((r) =>
            r.userId == userId &&
            r.date.isAfter(startDate.subtract(const Duration(days: 1))) &&
            r.date.isBefore(endDate.add(const Duration(days: 1))))
        .toList()
      ..sort((a, b) => b.date.compareTo(a.date));
  }

  /// Delete draft report
  Future<void> deleteDraftReport(String reportId) async {
    await Future.delayed(const Duration(milliseconds: 200));

    final report = _mockReports.firstWhere((r) => r.id == reportId);
    if (report.status != ReportStatus.draft) {
      throw Exception('Can only delete draft reports');
    }

    _mockReports.removeWhere((r) => r.id == reportId);
  }

  /// Get statistics for manager view
  Future<Map<String, dynamic>> getReportStatistics({
    required String companyId,
    required DateTime date,
  }) async {
    await Future.delayed(const Duration(milliseconds: 400));

    // TODO: Query from Supabase with proper filters
    final dayReports = _mockReports.where((r) {
      final reportDate = r.date;
      return reportDate.year == date.year &&
          reportDate.month == date.month &&
          reportDate.day == date.day;
    }).toList();

    final totalReports = dayReports.length;
    final submittedReports =
        dayReports.where((r) => r.status == ReportStatus.submitted).length;
    final avgHours = dayReports.isEmpty
        ? 0.0
        : dayReports.map((r) => r.totalHours).reduce((a, b) => a + b) /
            totalReports;
    final totalTasks = dayReports
        .map((r) => r.tasksCompleted)
        .fold(0, (sum, count) => sum + count);

    return {
      'total_reports': totalReports,
      'submitted_reports': submittedReports,
      'pending_reports': totalReports - submittedReports,
      'average_hours': avgHours,
      'total_tasks_completed': totalTasks,
      'submission_rate':
          totalReports > 0 ? (submittedReports / totalReports * 100) : 0,
    };
  }

  /// Get all reports for company on specific date (for Manager/CEO view)
  Future<List<DailyWorkReport>> getCompanyReports(
    String companyId,
    DateTime date,
  ) async {
    await Future.delayed(const Duration(milliseconds: 400));

    // TODO: Query from Supabase with company filter
    // For now, return all mock reports for the date
    final dayReports = _mockReports.where((r) {
      final reportDate = r.date;
      return reportDate.year == date.year &&
          reportDate.month == date.month &&
          reportDate.day == date.day;
    }).toList();

    // Sort by submission status and then by name
    dayReports.sort((a, b) {
      if (a.status != b.status) {
        return b.status.index.compareTo(a.status.index);
      }
      return a.userName.compareTo(b.userName);
    });

    return dayReports;
  }
}

// Riverpod Providers
final dailyWorkReportServiceProvider = Provider<DailyWorkReportService>((ref) {
  return DailyWorkReportService(Supabase.instance.client);
});

/// Today's report for current user
final todayWorkReportProvider =
    FutureProvider.family<DailyWorkReport?, String>((ref, userId) async {
  final service = ref.watch(dailyWorkReportServiceProvider);
  return await service.getTodayReport(userId);
});

/// All reports for user
final userWorkReportsProvider =
    FutureProvider.family<List<DailyWorkReport>, String>((ref, userId) async {
  final service = ref.watch(dailyWorkReportServiceProvider);
  return await service.getUserReports(userId);
});

/// All reports for branch (Manager view)
final branchWorkReportsProvider =
    FutureProvider.family<List<DailyWorkReport>, String>((ref, branchId) async {
  final service = ref.watch(dailyWorkReportServiceProvider);
  return await service.getBranchReports(branchId);
});

/// Report statistics for manager
final reportStatisticsProvider =
    FutureProvider.family<Map<String, dynamic>, Map<String, dynamic>>(
        (ref, params) async {
  final service = ref.watch(dailyWorkReportServiceProvider);
  return await service.getReportStatistics(
    companyId: params['companyId'] as String,
    date: params['date'] as DateTime,
  );
});
